#### 객체지향 프로그래밍(OOP)

* 객체지향 프로그래밍 정의
* 객체지향 프로그래밍 기초
  * 객체/인스턴스/클래스
  * 클래스
  * 메서드
* 객체지향의 핵심개념
  * 추상화
  * 상속
  * 다형성
  * 캡슐화



가. 객체지향 프로그래밍 정의

1. 컴퓨터 프로그래밍의 패러다임 중 하나 ex) 라면 끓이는데 스프 먼저 넣는다, 하나의 패러다임!

2. 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것

3. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.

   => **프로그램을 여러 개의 독립된 객체들과 그 객체 간의 상호작용으로 파악하는 프로그래밍 방법**

     cf) 객체 : 정보(변수)와 행동(함수)이 있는 모든 존재, 이 객체들끼리 상호작용! 

   ​    ex) 교수(검은옷, 맛잘알/춤, 말), 강아지(리트리버/먹기, 사기)

   ​    ex) 콘서트 프로그램은 가수 객체(키/노래, 춤), 감독 객체, 관객 객체의 상호작용으로 이루어짐

4. 과거 : 절차지향 프로그래밍(데이터와 함수로 인한 변화) 

   global data -> function1 -> function3

   ​                     -> function2 -> function4

   ​                     -> function5

   뭐가 문제? 하나 바꾸려면 다 같이 바꿔야 되는 문제가 생김!

   -> 현재 : 객체지향 프로그래밍(데이터와 기능(메서드) 분리, 추상화된 구조(인터페이스))

   ​    특정 기준에 맞춰서 object를 나눔

   ​        object          <=>            object

   ​         data                                data

     methods(함수)                 methods

   ​     methods

      채팅 올린다                         읽는다

5. 객체지향 프로그래밍이 필요한 이유 : 추상화!(복잡한 거 몰라도 쓸 수 있는 것)

     ex) 가수.노래() : 노래가 뭐하는지 몰라도 꾸러미 들고와서 쓸 수 있음.

6. 장점

   가) 클래스 단위로 모듈화(니 일(로그인 기능), 내 일(게시판 작업)) 나눌 수 있다 -> 여러 명이 참여 가능

   나) 필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉬움

7. 단점

   가) 설계 시 많은 노력과 시간 필요(빠른 설계 필요 시 객체지향을 안 넣는게 좋다)

   나) 실행속도가 상대적으로 느림(절차지향 프로그래밍이 컴퓨터의 처리 구조와 비슷해서 실행속도가 빠름)

나. 객체지향 프로그래밍 기초

1. 객체 : 속성(변수)과 행동(함수-메서드)으로 구성된 모든 것

     ex) 이찬혁.직업 -> 가수

   ​        이찬혁.랩하기() -> 어느새부터~

2. 클래스(설계도)     객체(실제 사례)

     가수, 강아지      이찬혁, 리트리버

   '가수'는 머릿속에만 있지 실제로는 예시(이찬혁)로만 존재

3. 클래스로 만든 객체를 인스턴스! '특정 타입, 클래스의 인스턴스'라고 표현함

   이찬혁은 객체다(o) 객체 : 정보 + 행동

   이찬혁은 인스턴스다(x)

   이찬혁은 '가수'의 인스턴스다(o)

4. 클래스(가수)와 객체(실제 사례)

     타입(list)

   클래스를 만든다 == 타입을 만든다

5. 파이썬은 모든 것이 객체(object)

   파이썬의 모든 것엔 속성과 행동이 존재한다.

6. [3,2,1].sort()

   리스트.정렬()

   객체.행동()

   정보. 함수

   객체[0] -> 3

   정보 : iterable(for문 돌릴 수 있다.)

7. [232, 89, 1], []은 모두 list의 인스턴스

8. 객체의 특징

   가) 타입 : 어떤 연산자와 조작이 가능하다.(이것도 하나의 저장하고 처리하는 방법)

     ex) 문자열+문자열, 숫자+숫자 는 다름

   나) 속성 : 어떤 상태(데이터)

   다) 조작법 : 어떤 행위(함수)

   라) 객체 = 속성(상태, 정보) + 기능(메서드)

다. 객체와 클래스 문법

1. 기본 문법

   가) 클래스 정의 : 함수처럼 정의해줘야 함. class MyClass는 인스턴스를 생성하기 위한 재료. 설명을 해줌. ex) 육식동물은 고기를 먹는다.

   나) 인스턴스 생성 : my_instance = MyClass()

   다) 메서드 호출 : my_instance.my_method()

   라) 속성 : my_instance.my_attribute

2. 객체의 설계도(클래스)를 가지고 객체(인스턴스)를 생성한다.

   가) 클래스 : 객체들의 분류 / 설계도

   나) 인스턴스 : 하나하나의 실체 / 예

   ```python
   class Person:
       pass
   
   print(type(Person)) # <calss 'type'>
   
   person1 = Person()
   
   print(isinstance(person1, Person)) # True
   print(type(person1)) # <class '__main__.Person'>
   ```

     cf) 파이썬은 모든 것이 객체, 모든 객체는 특정 타입의 인스턴스

3. 객체 비교하기

   가) == 

     1)동등한

     2)변수가 참조하는 객체가 동등한 경우 True, 쌍둥이(다른 사람), 깊은복사느낌

     3)주소가 어찌됐든 내용물이 같으면 ㅇ

   나) is

     1)동일한

     2)두 변수가 동일한 객체를 가리키는 경우 True, 분신술, 얕은복사느낌

     3)주소가 같으면o

   ```python
   a = [1, 2, 3]
   b = [1, 2, 3]
   print(a == b, a is b) # True False
   
   a = [1, 2, 3]
   b = a
   print(a == b, a is b) # True True
   ```

라. OOP 속성

1. 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미 -> '변수'라고 부름

2. 클래스 변수(같이 쓰는 거) / 인스턴스 변수(각자 쓰는 거)가 존재

   cf) 객체 = 정보(클래스 변수, 인스턴스 변수) + 행동

   ```python
   class Person:
       blood_color = 'red' # 클래스 변수
       population = 100 # 클래스 변수
       
       def __init__(self, name):
           self.name = name # 인스턴스 변수
      
   person1 = Person('지민')
   print(person1.name) # 지민
   ```

3. 인스턴스 변수 : 인스턴스가 개인적으로 가지고 있는 속성, 각 인스턴스들의 고유한 변수

   가) 생성자 메서드(__ init __)에서 self.<name>으로 정의(만들고)

     ex) 실제 사례를 만드는 것(설계도에서 이찬혁을 만드는 것)

   나) 인스턴스가 생성된 이후 <instance>.<name>으로 접근 및 할당(사용)

   ```python
   class Person:
       
       def __init__(self, name): # 인스턴스 변수 정의
           self.name = name
           
   john = Person('john') 
   print(john.name) # john # 인스턴스 변수 접근 
   john.name = 'John Kim' # 인스턴스 변수 할당
   print(john.name) # john Kim
   ```

4. 클래스 변수

   가) 한 클래스의 모든 인스턴스가 공유하는 값을 의미

   나) 같은 클래스의 인스턴스들은 같은 값을 갖게 됨

   다) 특정 사이트의 User 수 등은 클래스 변수를 사용해야 함(인스타그램 유저수 정보같은 모두가 같이 공유해야하는 것들, 사람의 피는 빨간색과 같은 누구나 아는 정보)

   라) 클래스 선언 내부에서 정의

   마) <classname>.<name>으로 접근 및 할당

   ```python
   class Circle():
       pi = 3.14 # 클래스 변수 정의
       
       def __init__(self, r):
           self.r = r # 인스턴스 변수
           
   c1 = Circle(5)
   c2 = Circle(10)
   
   print(Circle.pi) # 3.14
   print(c1.pi) # 3.14 # 면접문제!! 인스턴스.클래스변수 찾는 것!! 인스턴스 변수에 없으면 클래스 변수까지 찾는다!!
   print(c2.pi) # 3.14
   
   Circle.pi = 5 # 클래스 변수 변경
   print(Circle.pi) # 5
   print(c1.pi) # 5
   print(c2.pi) # 5
   
   '''
   c2.pi = 5 # 인스턴스 변수 변경
   print(Circle.pi) # 3.14 (클래스 변수)
   print(c1.pi) # 3.14 (클래스 변수)
   print(c2.pi) # 5 (새로운 인스턴스 변수가 생성됨)
   '''
   ```

   ```python
   # 사용자 수 계산하기 (인스턴스가 생성될 때마다 클래스 변수가 늘어나도록 설정)
   class Person:
       count = 0
       
       def __init__(self, name):
           self.name = name
           count += 1
           
   person1 = Person('아이유')
   person2 = Person('이찬혁')
   
   print(Person.count) # 2
   ```

마. OOP 메서드 : 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수), 클래스 안에 있는 함수

```python
class Person:
    
    def talk(self):
        print('안녕')
       
    def eat(self, food):
        print(f'{food}를 냠냠')
        
person1 = Person()
person1.talk() # 안녕
person1.eat('피자') # 피자를 냠냠
```

1. 메서드 종류

   가) 인스턴스 메서드

   나) 클래스 메서드

   다) 정적 메서드

2. 인스턴스 메서드

   가) 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드

   나) 클래스 내부에 정의되는 메서드의 기본

   다) 호출 시, 첫 번째 인자로 인스턴스 자기자신(self)이 전달됨, self가 있으면 인스턴스 메서드!!

   ```python
   class MyClass:
       
       def instance_method(self, arg1, ...):
           
   my_instance = MyClass()
   my_instance.instance_method(...)
   ```

   라) self

     1)인스턴스 자기자신

     2)호출 시 첫 번째 인자로 인스턴스 자신이 전달

       * 매개변수 이름으로 self를 첫 번째 인자로 정의

   마) 생성자 메서드

     1)인스턴스 객체가 생성될 때 자동으로 호출되는 메서드

     2)인스턴스 변수들의 초기값을 설정(인스턴스 생성, __ init __메서드 자동 호출)

     ```python
     class Person:
         
         def __init__(self):
             print('인스턴스가 생성되었습니다.')
             
     person1 = Person() # 인스턴스가 생성되었습니다.
     ```

   바) 매직 메서드(스페셜 메서드, 던더 메서드)

     1)Double underscore(__)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드

       ```python
       __str__(self) : 해당 객체의 출력 형태를 지정, 프린트 함수를 호출할 때 자동 호출, 어떤 인스턴스를 출력하면 __str__의 return 값이 출력
       __gt__(self, other) : 부등호 연산자(>, greater than)
       
       __len__(self), __repr__(self)
       __lt__(self, other), __le__(self, other), __eq__(self, other)
       __ge__(self, other), __ne__(self, other)
       ```

   ```python
   class Circle:
       
       def __init__(self, r):
           self.r = r
        
       def area(self):
           return 3.14 * self.r * self.r
       
       def __str__(self):
           return f'[원] radius: {self.r}'
       
       def __gt__(self, other):
           return self.r > other.r
       
   c1 = Circle(10)
   c2 = Circle(1)
   
   print(c1) # [원] radius: 10
   print(c1 > c2) # True
   print(c1 < c2) # False
   ```

   사) 소멸자 메서드 : 인스턴스 객체가 소멸되기 직전에 호출되는 메서드

     ```python
     class Person:
         
         def __del__(self):
             print('인스턴스가 사라졌습니다.')
             
     person1 = Person()
     del person1 # 인스턴스가 사라졌습니다.
     ```

3. 클래스 메서드

   가) 클래스가 사용할 메서드

   나) @classmethod 데코레이터를 사용하여 정의

   다) 호출 시, 첫 번째 인자로 클래스(cls)가 전달됨

   ```python
   class MyClass:
       
       @classmethod
       def class_method(cls, arg1, ...):
           
   MyClass.class_method(...)
   ```

   ```python
   class Person:
       count = 0 # 클래스 변수 
       def __init__(self, name): # 인스턴스 변수 설정
           self.name = name
           Person.count += 1
          
       @classmethod
       def number_of_population(cls):
           print(f'인구수는 {cls.count}입니다.')
           
   person1 = Person('아이유')
   person2 = Person('이찬혁')
   print(Person.count)
   ```

   라) 데코레이터

     1)함수를 어떤 함수로 꾸며서 새로운 기능을 부여

     2)@데코레이터(함수명) 형태로 함수 위에 작성

     3)순서대로 적용되기 때문에 작성 순서 중요

     ```python
     ## 데코레이터 없이 함수 꾸미기 ##
     def hello():
         print('hello')
         
     # 데코레이팅 함수
     def add_print(original): # 파라미터로 함수를 받는다.
     	def wrapper(): # 함수 내에서 새로운 함수 선언
             print('함수 시작') # 부가기능 -> original 함수를 꾸민다.
             origial()
             print('함수 끝') # 부가기능 -> original 함수를 꾸민다.
         return wrapper # 함수를 return 한다.
     
     add_print(hello)()
     # '함수 시작'
     # 'hello'
     # '함수 끝'
     
     print_hello = add_print(hello)
     print_hello()
     # '함수 시작'
     # 'hello'
     # '함수 끝'
     
     ## 데코레이터 활용 ##
     #데코레이팅 함수
     def add_print(original): # 파라미터로 함수를 받는다.
         def wrapper(): # 함수 내에서 새로운 함수 선언
             print('함수 시작') # 부가기능 -> original 함수를 꾸민다.
             original()
             print('함수 끝') # 부가기능 -> original 함수를 꾸민다.
         return wrapper # 함수를 return 한다.
     
     @add_print # add_print를 사용해서 prin_hello()함수를 꾸며주도록 하는 명령어
     def print_hello():
         print('hello')
         
     print_hello()
     # '함수 시작'
     # 'hello'
     # '함수 끝'
     ```

   

   