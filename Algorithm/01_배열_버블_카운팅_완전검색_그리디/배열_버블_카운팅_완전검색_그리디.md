#### APS(Algorithm Problem Solving)

* 알고리즘
* 배열
* 버블 정렬(Bubble Sort)
* 카운팅 정렬(Counting Sort)
* 완전검색
* 그리디(Greedy Algorithm)



가. 알고리즘 : 문제를 해결하기 위한 절차나 방법

1. 의사코드(슈도코드, Pseudocode)와 순서도

2. APS 과정의 목표는 보다 좋은 알고리즘을 이해하고 활용하는 것

3. 무엇이 좋은 알고리즘?

   가) 정확성 : 얼마나 정확하게 동작하는가

   나) 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가, 실행시간 초과하지 않는지, 시간복잡도로 표현

     1)실제 걸리는 시간을 측정(실제로 이렇게는 못함), 실행되는 명령문(연산)의 개수를 계산

     2)시간 복잡도 / 빅-오(O) 표기법 

      * 가장 큰 영향력을 주는 n에 대한 항만을 표시

      * 계수를 생략하여 표시

      * O(3n+2) =          O(3n)          =          O(n)

        ​                  최고차항만 선택         계수 3제거

      * n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간복잡도는? O(n)

      * O(logn)이 가장 연산수 적음

   다) 메모리 사용량 : 얼마나 적은 메모리를 사용하는가

   라) 단순성 : 얼마나 단순한가

   마) 최적성 : 더 이상 개선할 여지없이 최적화되었는가

나. 배열 

1. 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조 / 저장하는 형태, 방식을 나타냄 / 파이썬에서는 리스트

2. 필요성 : 일일이 만들지 말고, 둘 이상의 변수를 선언 가능, 배열을 활용해 연산 쉽게 가능

3. 1차원 배열의 선언 : 리스트

   ```python
   # 1차원 배열 선언의 예
   
   Arr = list() 
   Arr = []
   # 참조할 준비만 한 것임, 아직 참조 안 함
   
   Arr = [1, 2, 3] 
   Arr = [0] * 10
   # 초기화된 배열, 비어있는 배열(10칸짜리)
   
   
   # 1차원 배열의 접근 : 배열에 인덱스를 붙이면 변수의 역할을 해줌
   Arr[0] = 10 # 배열 Arr의 0번 원소에 10을 저장하라
   Arr[idx] = 20
   ```

4. 배열 활용 예제

   ```python
   '''
   9
   7 4 2 0 0 6 0 7 0
   '''
   
   N = int(input())
   arr = list(map(int, input().split()))
   
   input()만 하면 []기호 없고 통째로 문자열로 받은거임 '7 4 2 0 0 6 0 7 0'
   list(input()) ['7', ' ', '4', ' ', ...]
   list(input().split(' ')) ['7', '4', '2', ...] split(' ') 이렇게 하면 7  4 공백 2개일 때 빈칸 하나를 만들어버림.
   map(int, input().split())은 튜플로 받음.
   
   가장 큰 수를 찾을 수 있는가? (내장함수 사용 안 하고)
   maxV = arr[0] # 첫 번째 값을 최대값으로 가정, 0으로 초기화하면 -값이 있기 때문에 안돼!!, 절대값 10억 이하인 N개의 정수라고 문제에서 제시해주는 거 확인 잘 하기
   for i in range(1, N): # 나머지 모든 원소에 대해, len()하지 말고 정해준 값 N을 써주기
   	if arr[i] > maxV:
   		maxV = arr[i]
   print(maxV)
   
   월말평가(IM시험) 때 배열의 인덱스 연산을 잘 하는가!
   
   * 각 원소에 대해 오른쪽에 있는 원소 중 더 작은 원소의 개수 구하기
   cnt = [0]*N
   for i in range(N): # 각 원소에 대해
       for j in range(i+1, N): # 오른쪽에 있는 원소 for문으로 돌리기
           if arr[i] > arr[j]: # arr[i]보다 작다면
               cnt[i] += 1 # cnt에 1 더하기
   print(cnt)
   
   최대값의 위치, 같은 값이 있을 때는 맨 오른쪽
   N = int(input())
   arr = list(map(int, input().split()))
   maxIdx = 0 # 가정
   for i in range(1, N):
   	if arr[maxIdx] <= arr[i]: # 같아도 바꿔줌
   		maxIdx = i
   ```

다. 정렬(sort sorted 금지)

1. 버블 정렬
2. 카운팅 정렬
3. 선택 정렬
4. 퀵 정렬
5. 삽입 정렬
6. 병합 정렬

라. 버블 정렬(Bubble Sort)

1. 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

2. 정렬 과정

   가) 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동

   나) 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

   다) 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 함

3. O(n^2) / 이중for문 수준 / 비교와 교환 / 코딩이 가장 손쉽다.

   ```python
   for i : N-1 -> 1 # 구간의 끝을 정함
   	for j : 0 -> i-1 # 비교할 원소 중 왼쪽 원소의 인덱스
   		if arr[j] > arr[j+1] # 왼쪽이 크면
   			arr[j] <-> arr[j+1] # 자리바꿈
   
   for i in range(N-1, 0, -1) # 구간의 끝을 정함
   	for j in (i) # 비교할 원소 중 왼쪽 원소의 인덱스
       	if arr[j] > arr[j+1]: # 왼쪽이 크면
               arr[j], arr[j+1] = arr[j+1], arr[j] # 자리 바꿈
               
   # Q. 정렬의 수도코드를 완성하고 어느부분을 설명하라.
   # Q. 저 수도코드는 어느 정렬에 대한 것인가?
   ```

마. 카운팅 정렬(Counting Sort)

1. 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

2. 제한 사항

   가) 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 '발생 횟수'를 기록하기 위해 정수항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문

   나) 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.

3. O(n+k) : n은 리스트 길이, k는 정수의 최대값 / 비교환 방식 / n이 비교적 작을 때만 가능

   ```python
   # 범위 : 0 이상 10이하의 정수가 주어진다.
   # [0, 4, 1, 3, 1, 2, 4, 1] 여기서 가장 많이 등장하는 숫자는? 
   for i in range(N): # 여기서 N은 원소 개수(8)
   	counts[arr[i]] += 1 # counts배열 0 0 0 0 0 으로 설정 / counts[k]는 k의 발생 횟수
   # counts = [1, 3, 1, 1, 2]
   # 카운트 배열은 100만까지만 가능하다.
   
   # 이전까지의 개수(각 항목의 앞에 위치한 항목의 개수)
   for i : 1 -> N-1
   	counts[i] += counts[i-1]
   # counts = [1, 4, 5, 6, 8]
   
   # [0, 4, 1, 3, 1, 2, 4, 1]에서 맨 뒤부터 검색
   # 맨 뒤가 1이라서 counts[1]을 감소시키고 Temp에 1을 삽입한다.
   arr[i] = 1
   counts[arr[i]] -= 1 # counts[1] -= 1 / counts[1] = 3 / counts[arr[i]] = 3
   Temp[counts[arr[i]]] = arr[i] # Temp[3] = arr[i] / Temp[3] = 1
   
   # counts 만들때는 index error 안나도록 해야함
   
   
   def Counting_Sort(A, B, k)
   # A [] -- 입력 배열(0 to k)
   # B [] -- 정렬된 배열
   # C [] -- 카운트 배열
   
   	C = [0] * (k+1)
       
       for i in range(0, len(A)):
           C[A[i]] += 1
          
       for i in range(1, len(c)):
           C[i] += C[i-1]
           
       for i in range(len(B)-1, -1, -1):
           C[A[i]] -= 1
           B[C[A[i]]] = A[i]
   
           
   tmp = [0] * N
   c = [0] * 101 # 0부터 100까지의 숫자 개수, 인덱스가 101까지 있어야 함
   for i in range(N): # 카운트
       c[arr[i]] += 1
   for j in range(1, 101): # 개수 누적
       c[j] += c[j-1]
   for i in range(N-1, -1, -1) # 원본을 뒤에서부터 읽으면서 정렬 결과를 tmp에 저장
   		c[arr[i]] -= 1
   		tmp[c[arr[i]]] = arr[i]
   ```

바. 완전 검색

1. 모든 경우의 수를 나열해보고 확인하는 기법

2. Brute-force 혹은 generate-and-test 기법이라고도 불림.

3. 순열

   ```python
   순열로 생성 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열
   
   A[1] = A[0]+1 
   A[2] = A[1]+1 
   
   # {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수 만들어보기
   for i1 in range(1, 4):
       for i2 in range(1, 4):
           if i2 != i1:
               for i3 in range(1, 4):
                   if i3 != i1 and i3 != i2:
                       print(i1, i2, i3)
   ```

4. 탐욕 알고리즘 : 완전검색보다는 적게 돌리는 방법

   가) 최적해를 구하는 데 사용되는 근시안적인 방법

   나) 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

   다) 동작과정 ex) 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

     1)해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다. ex) 가장 단위가 큰 동전 하나를 골라 거스름돈에 추가한다.

     2)실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다. ex) 거스름돈이 손님에게 내드려야하는 액수를 초과한다면 마지막에 추가한 동전을 빼고 1)로 돌아가서 한 단계 작은 단위의 동전을 추가한다. 

     3)해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다. ex) 거스름돈이 손님에게 내드려야하는 액수보다 모자르다면 1)로 돌아가 추가할 동전을 고른다.

5. Baby-gin을 완전검색이 아닌 방법으로 풀어보자! counts를 이용해보자!

   ```python
   444345
   input() # map은 (int,iterable)
   arr = list(map(int,input()) # 입력값의 공백이 없다면 split 뺀다.
   
              
   num = 456789          
   # count 함수 : 각 자리 수를 추출하여 개수를 누적할 리스트
   c = [0] * 12 # 12개로 리스트 만듦(꼼수), 칸을 더 붙여놓는게 아래 조건문에 추가하는 것보다 덜 귀찮다.
              
   # 자리가 정해져 있으면!!
   for i in range(6):
   	c[num%10] += 1 # num%10 : 일의자리수
       num //= 10 # num//10 : 일의자리수 날리기
              
   # 자리가 정해져 있지 않다면!!(input할 때마다 달라진다면?) 이렇게!! 외워!!
   # (잘라낸 자리수가 있다는 얘기는..)
   while num > 0:
   	c[num%10] += 1
   	num //= 10
              
              
   i = 0 
   tri = run = 0
   while i < 10:
   	if c[i] >= 3:
           c[i] -= 3
   		tri += 1
           continue
   	if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
           c[i] -= 1
           c[i+1] -= 1
           c[i+2] -= 1
           run += 1
           continue
   	i += 1 # 여기에 i에 1을 더해줘야 함.
             
   if tri + run == 2:
   	print('Baby Gin')
   else:
       print('Lose')
   ```

   