#### 문자열(String)

* 문자열
* 패턴 매칭
* 문자열 암호화(x)
* 문자열 압축(x)



가. 문자의 표현

1. 문자는 메모리에 저장!

2. 원래는 비트맵(그림) 형식으로 저장 → 가장 효율적인게 뭐가 있을까 해서 나온게 비트

3. 000000 → a, 000001 → b 모든 것들을 표현할 수 있다고 해서 코드체계라고 함.

4. 미국 주 마다 다름 → 표준안 만들게 됨(아스키 코드) 약자 암기!!(American Standard Code for Information Interchange)

5. 스페이스바 : 32, 그러니 스페이스바도 잘못 넣으면 안됨

   a : 97, A : 65 / 영대소문자 26개씩

6. 표준 아스키 : 7비트 128문자 → 다 표현 못하니 확장 아스키 형식을 사용

7. 국가들마다 대화가 안돼! 모든 언어(다국어)를 잘 표현할 수 있는 유니코드

8. (안중요하나..)  하지만 유니코드를 해석하는 인코딩이 필요해졌어 → 값을 어떻게 처리하냐

   가) 큰 단위가 앞에 나오는게 : big-endian

   나) 작은 단위가 앞에 나오는게 : little-endian

     1)1278

   ​     1000

   ​     200

   ​     70

   ​     8

   ​     7812 little endian 은 12부터 읽고 78 읽음 (안중요)

9. 유니코드 인코딩

   가) UTF-8 : 아스키랑 완전 호환 가능, 완전 해석 잘됨 (8비트)

10. Python 3버전은 UTF-8 생략 가능, java는 16방식

나. 문자열

1. 분류 : 고정된 값 (파이썬은 이거!!) / 변화된 값(자바, C)

2. java에서 String 클래스 배치

   가) hash = hash값

   나) count = 문자열의 길이

   다) offset = 문자열 데이터의 시작점

   라) value = 실제 문자열 배열에 대한 참조

   ```java
   // Java에서 문자열 처리
   String a = '안녕'; // 문자 선언 방법1 String으로 만들어줘야 함.
   strlen(), strcpy() // Python에서 아는 len() -> 값을 모두 리스트화 시켜서 계산
   String b = new String("abc"); // 문자 선언 방법2
   // 메소드 형태로 세부연산 가능
   ```

3.  C에서 문자열 처리

   가) 모든 문자열 끝에 \0을 넣어줘야 함

   ```c
   char ary[] = {'a', 'b', '\0'}; // 배열 선언
   
   // strlen() 함수 만들어보기
   def strlen(input_str):
   	idx = 0
   
   	while 1:
   		if input_str[idx] == '\0':
   			return idx// return 하는 거 자체가 종료해라(break안해줘도 됨)
   		idx += 1
   
   a = ['a', 'b', 'c', '\0']
   print(strlen(a))
   ```

4. Python에서 문자열 처리

   ```python
   a = '3'
   b = 4
   '', "",""" """,''' '''
   + : 문자열을 붙여주고(더해주기)
   * : 문자열을 *수만큼 반복
   
   문자열(+ 튜플도)을  immutable.. 변하지 못하는 속성은 있지만
   시퀀싱이다. <- 바꿀 수는 없지만 자를 수 있다. == 슬라이싱 가능
   
   a = [1, 2, 3, 4, 5, 6, 7]
   a = [7, 6, 5, 4, 3, 2, 1] 리스트는 순서 바꿀 수 있지만 문자열은 안 돼 
   a[:-2]
   ```

5. C, Java, String 처리의 기본적인 차이점

   가) C → 아스키로 저장 (다국어 처리가 어려움)

   나) java → UTF-16로 저장 (혼동이 온다.)

   다) 파이썬은 UTF-8으로 저장 (다국어 가능)

   ```c
   // C언어
   char * name = "정유현";
   int count = strlen(name);
   printf("%d", count); // 6
   ```

   ```java
   String name = "정유현";
   String name = new String("정유현");
   System.out.println(name.length()) //ln은 개행 한줄 띄어 print 한줄 안띄어
   // 3
   ```

   ```python
   name = "정유현"
   print(len(name)) # 3
   ```

6. String Reverse(문자열 뒤집기)

   가) 문자열은 불변

   나) 인덱스로 접근해서 문자를 바꾸는게 불가

   다) 방법

     1)slicing

   ```python
   s = 'Reverse this strings' # 문자열 저장
   s = [::-1]
   print(s)
   # sgnirts siht esreveR
   ```

     2)reverse 메소드

   ```python
   내장함수
   len() max() min() 불가
   .append .reverse 가능
   
   s = 'Reverse this strings' # 문자열 저장
   s = list(s) # 리스트화
   # ['R', 'e', ...]
   s.reverse(rev)
   # ['s', 'g', ...]
   s = ''.join(s)
   print(s)
   # sgnirts siht esreveR
   ```

     3)for문으로

   ```python
   s = 'Reverse this strings' # 문자열 저장
   reversed_s = ''
   
   for i in range(len(s)-1, -1, -1):
   	reversed_s += i # 문자열은 더해주면 붙여짐!! append가 아니라!!
   
   print(reversed_s) # sgnirts siht esreveR
   
   
   # 앞, 뒤를 교환
   s = 'algorithm' # 문자열 저장
   list_s = list(s) # 리스트화
   
   for j in range(len(list_s)//2):
   	# 9 // 2 -> 4
   	start, end = j, -(j+1)
   	list_s[start], list_s[end] = list_s[end], list_s[start]
   
   s = ''.join(list_s)
   print(s) # mht...
   ```

7. String Compar (문자열 비교)

   가) C에서는 strcmp()

   나) Java에서는 .equals()

     1)==은 메모리 참조 값이 같니?(쉘로카피니?)

   다) Python에서는 ==, is 연산자가 있다.

     1)== : value(값)이 같은 때 True

       * __ eq __()

     2)is : Object(객체)가 같을 때 True

   * 메모리 주소를 비교하기 때문에

   ```python
   s1 = 'abc'
   s2 = 'abc'
   s3 = 'def'
   s4 = s1 
   s5 = s1[:2] +'c'
   
   s1 == s2 # True
   s1 == s3 # False
   s1 == s4 # True
   s1 == s5 # True
   
   s2 == s3 # False
   s2 == s4 # True
   s2 == s5 # True
   
   s3 == s4 # False
   s3 == s5 # False
   
   s4 == s5 # True
   
   s1 is s2 # 
   s1 is s3 # 
   s1 is s4 # 
   s1 is s5 # 
   
   s2 is s3 # 
   s2 is s4 # 
   s2 is s5 # 
   
   s3 is s4 # 
   s3 is s5 # 
   
   s4 is s5 # 
   ```

   ```c
   // 그냥 보고 넘어가자
   int my_strcmp(const char *str1, const char *str2)
   {
   	int i = 0;
   	while (str[i] != '\0')
   	{
   		if (str1[i] != str2[i]) break;
   		i ++
   	}
   	return (str1[i] - str2[i]);
   }
   ```

   ```python
   def my_strcmp(str1, str2):
   	n = min(len(str1), len(str2)) # 짧은 길이 선택
    
   	for i in range(n):
   		if str1[i] != str2[i]:
   			return ord(str1[i]) - ord(str2[i])
   	
   	# 작은 str 값을 기준으로, 내가 원하는 str까지 일치할 때!  
   	else:
   		# 만약에 둘이 길이가 같아 그러면 0 리턴
   		if len(str1) == len(str2):
   			return 0
   		else:
   			# str1 길이가 길 때 1, 길이가 짧을 때 -1
   			if len(str1) > len(str2):
   				return 1
   			else:
   				return -1
   
   # 그냥 보고 넘어가 
   ```

8. String to Interger(문자를 정수로 변환)

   가) C언어

     1)atoi() : ascii to integer(문자를 숫자로)

   ```c
   s = "2021";
   i = atoi(s); // 2021
   ```

     2)itoa() : integer to ascii(숫자를 문자로)

   ```c
   i = 2021;
   s = itoa(i); // "2021"
   ```

   나) Java

     1)Parse  메소드를 활용하면 된다(문자를 숫자로)

   ```java
   String s = "2022"
   int i = Integer.parseInt(s);
   ```

     2).toString() : integer to ascii(숫자를 문자로)

   ```java
   int i = 2023;
   String
   ```

   다) 파이썬

     1)int(), float()으로 문자를 숫자로 바꿀 수 있다.

     2)str(), repr()

     3)C에서의 atoi()를 python으로 구현

   ```python
   def atoi(s):
   	i = 0
   	for x in s:
   		# 현재 i의자리수를 한 자리 증가 + 만들어진 일의 자리 수에서 0 변환 한 숫자 더하기
   		i = i * 10 + ord(x)-ord('0')
   	return i 
   # 중요하지 않아..
   
   s = '123'
   print(atoi(s)+1) # 숫자에다가 + 1 = 124
   ```

   라) C에서의 itoa()를 파이썬으로 구현

   ```python
   def itoa(i):
   	if i == 0:
   		return '0'
   	
   	if i < 0:
   		flag = False
   		i = -i
   	else:
   		flag = True
   
   result = ''
   ```

다. 패턴 매칭

1. 패턴 매칭에 사용되는 알고리즘

   가) 고지식한 패턴 검색 알고리즘(완전 탐색, Brute Force)

     1)반복문을 돌면서 하나씩 다 확인

 